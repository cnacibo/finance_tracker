# Контрольная работа КПО №1. Паттерны проектирования.
---
## Содержание

1. [Общая идея решения](#1-общая-идея-решения)
2. [Принципы SOLID и GRASP](#2-принципы-solid-и-grasp)
3. [Паттерны GoF](#3-паттерны-gof)
4. [Инструкция по запуску приложения](#4-Инструкция-по-запуску-приложения)

---
## 1. Общая идея решения

FinanceTrackerApp является приложением для учета финансовых операций, включающее управление банковскими счетами, категориями операций и операциями. 

**Основной функционал включает:**

* Управление банковскими счетами: создание, изменение, удаление счетов, пополнение и снятие средств.
* Управление категориями: создание, изменение и удаление категорий для операций.
* Управление операциями: создание, изменение и удаление операций, связанных с счетами и категориями.
* Аналитика операций: анализ операций по категориям, расчет разницы между доходами и расходами за определенный период.
* Импорт и экспорт данных: возможность импорта и экспорта данных в форматах JSON, CSV и YAML.
* Командный интерфейс: реализация команд для выполнения пользовательских сценариев. 

**Структура проекта:**

## 2. Принципы SOLID и GRASP

###Принципы SOLID

**1. Single Responsibility Principle (SRP):**

Каждый класс отвечает за одну задачу:
* BankAccountFacade - управление банковскими счетами.
* CategoryFacade - управление категориями.
* OperationFacade - управление операциями.
* CsvExportVisitor, JsonExportVisitor, YamlExportVisitor - экспорт данных в разные форматы.

**2. Open/Closed Principle (OCP):**

Классы открыты для расширения, но закрыты для модификации:
* AnalyticsContext может работать с любыми стратегиями анализа (IAnalyticsStrategy), не требуя изменений.
* Классы экспорта данных реализуют интерфейс IExportVisitor, соответственно можно добавлять новые форматы экспорта без изменения существующего кода.

**3. Liskov Substitution Principle (LSP):

Наследники могут использоваться вместо базовых классов:
* CategoryGroupingStrategy и IncomeExpenseDifferenceStrategy реализуют интерфейс IAnalyticsStrategy и могут использоваться в AnalyticsContext.

**4. Interface Segregation Principle (ISP):

Интерфейсы разделены на мелкие и специфичные:
* IAnalyticsStrategy содержит только метод Analyze, что делает его узкоспециализированным.
* IExportVisitor содержит только метод Visit, что позволяет реализовывать различные стратегии экспорта.

**5. Dependency Inversion Principle (DIP):

Зависимости строятся на абстракциях, а не на конкретных реализациях:
* BankAccountFacade, CategoryFacade, OperationFacade зависят от интерфейса IFinanceFactory, а не от конкретной реализации.

###Принципы GRASP

** 1. High Cohesion:

Классы имеют высокую связность, так как каждая ответственность четко определена:
* BankAccountFacade отвечает только за управление счетами.
* CategoryFacade отвечает только за управление категориями.

** 2. Low Coupling:

Классы слабо связаны между собой благодаря использованию интерфейсов и фасадов:
* OperationFacade зависит от BankAccountFacade и CategoryFacade, но связь между ними минимальна благодаря использованию интерфейсов.

** 3. Creator:

Классы создают объекты, которые они используют:
* FinanceFactory создает объекты BankAccount, Category и Operation.

** 4. Controller:

Классы CategoryAnalysisCommand, IncomeExpenseAnalysisCommand, ExportDataCommand и другие команды выступают в роли контроллеров, управляющих выполнением операций.


## 3. Паттерны GoF

### 1. Фасад (Facade)✅
**Назначение:**

Фасад — это структурный паттерн, который предоставляет упрощенный интерфейс для взаимодействия с группой сложных подсистем. В вашем случае фасад помогает объединить работу с различными аспектами приложения в более удобный и простой интерфейс. 
Например:

* CategoryFacade — фасад для работы с категориями (создание, изменение, получение, удаление).
* BankAccountFacade — фасад для работы с банковскими счетами.
* OperationFacade — фасад для операций с деньгами.

**Зачем он нужен:**

* Упрощение взаимодействия с подлежащими подсистемами, предоставляя один интерфейс для работы с несколькими методами.
* Сокрытие сложности и деталей реализации от пользователя.


---
### 2. Команда (Command) и Декоратор (Decorator)❓
**Назначение:**

* Команда (Command) позволяет инкапсулировать запрос как объект, что позволяет передавать его, ставить в очередь, логировать или отменять.
* Декоратор (Decorator) — это структурный паттерн, который позволяет добавлять новое поведение объекту динамически, не изменяя его исходный код.

**Зачем они нужны:**

* Команда поможет вам представлять каждый пользовательский сценарий как команду, что позволяет легко управлять ими, например, ставить их в очередь или отменять.
* Декоратор позволяет оборачивать команды дополнительным функционалом, таким как логирование времени выполнения, без изменения самого класса команды.

---

### 3. Шаблонный метод (Template Method)✅
**Назначение:**

Шаблонный метод — это поведенческий паттерн, который позволяет определить структуру алгоритма, делегируя выполнение некоторых шагов в подклассы.

**Зачем он нужен:**

Когда алгоритм в основном остается неизменным, но части его логики могут изменяться. Это полезно, например, для парсинга данных из различных форматов файлов, где процесс может быть схожим (например, чтение из файла), но детали (например, способ парсинга данных) могут отличаться.

---

### 4. Посетитель (Visitor)✅
**Назначение:**

Посетитель — это поведенческий паттерн, который позволяет добавлять новые операции к объектам, не изменяя их. Он позволяет отделить алгоритмы от объектов, над которыми они выполняются.

**Зачем он нужен:**

Когда необходимо выполнять различные операции над объектами, не изменяя их классы, например, для выгрузки данных в файл. Вместо того, чтобы добавлять логику выгрузки в каждый класс, вы можете создать класс-посетитель, который будет реализовывать логику выгрузки.

---

### 5. Фабрика (Factory)✅
**Назначение:**

Фабрика — это порождающий паттерн, который предоставляет интерфейс для создания объектов, но позволяет подклассам решать, какой класс инстанцировать.

**Зачем он нужен:**

Гарантирует, что создание объектов происходит в одном месте и позволяет централизованно управлять процессом создания объектов, включая валидацию. Например, с помощью фабрики можно гарантировать, что объекты Operation создаются только с положительным значением amount.



## 4. Инструкция по запуску приложения

Требования:
Установленный .NET SDK (версия 6.0 или выше).
Редактор кода (например, Visual Studio, Visual Studio Code).
Запуск приложения:
Склонируйте репозиторий с проектом.
Откройте проект в редакторе кода.
В терминале перейдите в папку с проектом и выполните команду:
bash
Copy
dotnet run
Приложение запустится и выполнит демонстрационные команды, такие как создание счетов, категорий, операций, анализ данных, экспорт и импорт.
Демонстрационные данные:
Приложение создает демонстрационные данные (счета, категории, операции) и выполняет анализ, экспорт и импорт данных.
Файлы экспорта:
После выполнения экспорта в папке с проектом появятся файлы:
export.json (экспорт в JSON).
export.csv (экспорт в CSV).
export.yaml (экспорт в YAML).
Импорт данных:
Для импорта данных используются файлы, созданные при экспорте. Приложение автоматически импортирует данные из этих файлов.
